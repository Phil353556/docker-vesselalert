#!/usr/bin/with-contenv bash
#shellcheck shell=bash
#shellcheck disable=SC2015,SC1090,SC2164,SC2001
###shellcheck disable=SC2016,SC2068,SC2076,SC2086,SC2015,SC2164,SC1090,SC2001

# Mastodon-Notifier
# Send notification to Mastoron
# create and maintain a CSV database with this data

# redirect stderr to stdout so it's picked up in the docker logs
exec 2>&1
# all errors will show a line number and the command used to produce the error
SCRIPT_PATH="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; pwd)/$(basename "$0")"
trap 'echo -e "[$(date)][$APPNAME][ERROR] $SCRIPT_PATH in line $LINENO when executing: $BASH_COMMAND returned ${?}"' ERR

APPNAME="$(hostname)/mastodon-notifier"
echo "[$(date)][$APPNAME] Started as an s6 service"

sleep infinity

[[ -z "${CHECK_INTERVAL}" ]] && CHECK_INTERVAL=30 || true
[[ -z "${VESSELDBFILE}" ]] && VESSELDBFILE="/data/vessel.db" || true
[[ -z "${VESSELDBLOCK}" ]] && VESSELDBLOCK="/run/vesseldb.lock" || true
[[ -z "${MIN_MSG_COUNT}" ]] && MIN_MSG_COUNT=5 || true
[[ -z "${MAX_MSG_AGE}" ]] && MAX_MSG_AGE=86400 || true
[[ -z "${MASTODON_FORMAT}" ]] && MASTODON_FORMAT=("mast" "last_notif" "lat" "lon")
MASTODON_SERVER="${MASTODON_SERVER,,}"
[[ -z "${MASTODON_SERVER}" ]] && MASTODON_SERVER="airwaves.social"
[[ "${MASTODON_SERVER:0:7}" == "http://" ]] && MASTODON_SERVER="${MASTODON_SERVER:7}" || true
[[ "${MASTODON_SERVER:0:8}" == "https://" ]] && MASTODON_SERVER="${MASTODON_SERVER:8}" || true
MASTODON_SERVER="https://${MASTODON_SERVER}"
notification_count=0
[[ -n "$DEBUG" ]] && mastpost_visibility="private" || mastpost_visibility="public"

touch "$VESSELDBFILE"
rm -f "$VESSELDBLOCK"

# This is the format of the VESSELDICT associative array records:
# [mmsi, shipname, callsign, country, lat, lon, level, count, ppm, speed, destination, last_signal, notification_attributes_1, notification_attributes_2, ...]
#   0       1          2         3     4    5     6       7    8      9       10            11              12                          13       <-- field index for BASH
#   1       2          3         4     5    6     7       8    9     10       11            12              13                          14       <-- field index for AWK

# Define some functions to calculate distance between coordinates using Haversine:
deg2rad () {
    bc -l <<< "$1 * 0.0174532925"
}

rad2deg () {
    bc -l <<< "$1 * 57.2957795"
}

acos () {
    pi="3.141592653589793"
    bc -l <<< "$pi / 2 - a($1 / sqrt(1 - $1 * $1))"
}

distance () {
    lat_1="$1"
    lon_1="$2"
    lat_2="$3"
    lon_2="$4"
    delta_lat="$(bc <<<"$lat_2 - $lat_1")"
    delta_lon="$(bc <<<"$lon_2 - $lon_1")"
    lat_1="$(deg2rad "$lat_1")"
    lon_1="$(deg2rad "$lon_1")"
    lat_2="$(deg2rad "$lat_2")"
    lon_2="$(deg2rad "$lon_2")"
    delta_lat="$(deg2rad "$delta_lat")"
    delta_lon="$(deg2rad "$delta_lon")"
    distance="$(bc -l <<< "s($lat_1) * s($lat_2) + c($lat_1) * c($lat_2) * c($delta_lon)")"
    distance="$(acos "$distance")"
    distance="$(rad2deg "$distance")"
    distance="$(bc -l <<< "$distance * 60")"
    distance="$(bc <<<"scale=4; $distance / 1")"
    echo "$distance"
}

# ---------------------------------------------------------------------------------------

while true
do

    # 3 main arrays:
    # - VESSELDICT is an associative array that contains all the vessels, indexed by their MMSI.
    #   So: ${!VESSELDICT[@]} contains the list of MMSIs, and ${VESSELDICT[$mmsi]}
    #   contains a comma-separated list of parameter values.
    #
    # - vesselinfo is an associative array that contains the information of a single vessel from
    #   the VESSELDICT array. The ${headers[@]} array contains the keys for each of these values.
    #
    # - mast_status is extracted from the right-most "notif_x" field from vesselinfo that starts with "mast="
    #   This array contains information about previous notifications to Mastodon for this MMSI
    #   The keys to this array are defined in MASTODON_FORMAT

    # If there's a lock file, wait until it's gone\
    while [[ -f  $VESSELDBLOCK ]]
    do
        sleep 1
    done

    # Now lock the process for myself:
    touch "$VESSELDBLOCK"

    # First read the existing entries in from file
    if (( $(wc -l < "$VESSELDBFILE") > 0 ))
    then
        [[ -n "$DEBUG" ]] && echo reading shipdict from file || true
        source "$VESSELDBFILE"
    fi

    # Iterate through the ships:
    for vessel in "${VESSEL_INDEX[@]}"
    do

        [[ -z "${VESSELS[$vessel:mmsi]}" ]] && continue || true    # capture empty mmsi and skip
        # now we have the mastodon notification status of the vessel in mast_status. Let's check if we need to notify:
        unset notify

        # do some safeguarding:
        [[ -z "${VESSELS[$vessel:mast_lat]}" ]] && VESSELS[$vessel:mast_lat]="false" && true
        [[ -z "${VESSELS[$vessel:mast_lon]}" ]] && VESSELS[$vessel:mast_lon]="false" && true
        [[ -z "${VESSELS[$vessel:mast_last]}" ]] && VESSELS[$vessel:mast_last]="$MASTODON_NOTIFY_EVERY" && true

        # based on timing:
        if [[ -n "$MASTODON_NOTIFY_EVERY" ]] && (( ${VESSELS[$vessel:mast_last]} < $(date +%s) - MASTODON_NOTIFY_EVERY ))
        then
            [[ -n "$DEBUG" ]] && echo "${VESSELS[$vessel:mmsi]} notify based on timing"
            notify="true"
        else
            [[ -n "$DEBUG" ]] && echo "${VESSELS[$vessel:mmsi]} skipped notify based on timing ( MASTODON_NOTIFY_EVERY=$MASTODON_NOTIFY_EVERY, ${VESSELS[$vessel:mast_last]} < $(date +%s) - $MASTODON_NOTIFY_EVERY )"
        fi

        # based on distance from last notification:
        if [[ -n "${MASTODON_MIN_DIST}" ]]
        then
            if [[ "${VESSELS[$vessel:mast_lat]}" == "false" ]] ||  [[ "${VESSELS[$vessel:mast_lon]}" == "false" ]] || (( $(distance "${VESSELS[$vessel:mast_lat]}" "${VESSELS[$vessel:mast_lon]}" "${VESSELS[$vessel:lat]}" "${VESSELS[$vessel:lon]}") > MASTODON_MIN_DIST ))
            then
                [[ -n "$DEBUG" ]] && echo "${VESSELS[$vessel:mmsi]} notify based on distance"
                notify="true"
            else
                [[ -n "$DEBUG" ]] && echo "${VESSELS[$vessel:mmsi]} skipped notify based on distance ( measured $(distance "${VESSELS[$vessel:mast_lat]}" "${VESSELS[$vessel:mast_lon]}" "${VESSELS[$vessel:lat]}" "${VESSELS[$vessel:lon]}") > allowed $MASTODON_MIN_DIST )"
            fi
        else
                [[ -n "$DEBUG" ]] && echo "${VESSELS[$vessel:mmsi]} notify based on distance (disabled)"
        fi

        # don't notify if it matches the Skip Filter
        if [[ -n "${MASTODON_SKIP_FILTER}" ]]
        then
            if [[ ${VESSELS[$vessel:mmsi]} =~ ${MASTODON_SKIP_FILTER} ]]
            then
                unset notify
                [[ -n "$DEBUG" ]] && echo "${VESSELS[$vessel:mmsi]} skipped because of mmsi filter match (${MASTODON_SKIP_FILTER})"
            else
                [[ -n "$DEBUG" ]] && echo "${VESSELS[$vessel:mmsi]} didn't match mmsi skip filter (${MASTODON_SKIP_FILTER})"
            fi
        else
            [[ -n "$DEBUG" ]] && echo "${VESSELS[$vessel:mmsi]} -> skip filter disabled"
        fi

        if [[ -n "$notify" ]]
        then
            # we need to notify
            # First create notification string
            # These are the valid fields:
            # mmsi lat lon distance mmsi_type level count ppm heading cog speed to_bow to_stern to_starboard to_port shiptype msg_type country status callsign shipname destination last_signal mast_lat mast_lon mast_last
            links=""
            [[ -n "$MASTODON_LINK_SHIPXPLORER" ]] && links+="https://www.shipxplorer.com/data/vessels/IMO-MMSI-${VESSELS[$vessel:mmsi]} " || true
            [[ -n "$MASTODON_LINK_MARINETRAFFIC" ]] && links+="https://www.marinetraffic.com/en/ais/details/ships/${VESSELS[$vessel:mmsi]} " || true
            [[ -n "$MASTODON_LINK_VESSELFINDER" ]] && links+="https://www.vesselfinder.com/vessels/details/${VESSELS[$vessel:mmsi]} " || true

            mast_str="#VesselAlert #Ship #Vessel #AIS\n"
            [[ -n "${VESSELS[$vessel:shipname]}" ]] && mast_str+="Name: #${VESSELS[$vessel:shipname]} "
            [[ -n "${VESSELS[$vessel:mmsi]}" ]] && mast_str+="#MMSI: #${VESSELS[$vessel:mmsi]} "
            [[ -n "${VESSELS[$vessel:callsign]}" ]] && mast_str+="Call: #${VESSELS[$vessel:callsign]} "
            [[ -n "${VESSELS[$vessel:shiptype]}" ]] && mast_str+="Type: ${SHIPTYPE[${VESSELS[$vessel:shiptype]}]}"
            mast_str+="\n"

            [[ -n "${VESSELS[$vessel:country]}" ]] && mast_str+="#Flag: #${VESSELS[$vessel:country]} "
            mast_str+="Last seen: $(date -d @$(( $(date +%s) - ${VESSELS[$vessel:last_signal]} )) +"%d-%b-%Y %H:%M:%S %Z") Msgs recvd: ${VESSELS[$vessel:count]}"
            mast_str+="\n"

            [[ -n "${VESSELS[$vessel:speed]}" ]] && mast_str+="Speed: ${VESSELS[$vessel:speed]} kts "
            [[ -n "${VESSELS[$vessel:heading]}" ]] && mast_str+="Heading: ${VESSELS[$vessel:speed]} deg "
            [[ -n "${VESSELS[$vessel:destination]}" ]] && mastr_str+="Destination: ${VESSELS[$vessel:destination]}"
            mast_str+="\n"

            mast_str+="#Signal (#RSSI): $(printf "%.1f dBFS" "${VESSELS[$vessel:level]}")"
            [[ -n "$links" ]] && mast_str+="\n$links"

            mast_str="$(sed -e 's|\\n|\n|g' <<< "$mast_str")"

            # Now we can finally send this to Mastodon
            # First let's get an image if it exists from MarineVessel:

            image_link="https://photos.marinetraffic.com/ais/showphoto.aspx?mmsi=${VESSELS[$vessel:mmsi]}"
            media_id=""
            if curl -sL -A "Mozilla/5.0 (X11; Linux x86_64; rv:97.0) Gecko/20100101 Firefox/97.0" "$image_link" -o "/tmp/vesselimg.jpg"
            then
                response="$(curl -s -H "Authorization: Bearer ${MASTODON_ACCESS_TOKEN}" -H "Content-Type: multipart/form-data" -X POST "${MASTODON_SERVER}/api/v1/media" --form file="@/tmp/vesselimg.jpg")"
                [[ "$(jq '.id' <<< "$response" | xargs)" != "null" ]] && mast_id="$(jq '.id' <<< "$response" | xargs)" || mast_id=""
                rm -f "/tmp/vesselimg.jpg"
                [[ -n "${mast_id}" ]] && media_id="-F media_ids[]=${mast_id}"
                echo "[$(date)][$APPNAME] image uploaded to Mastodon"
            fi

            #shellcheck disable=SC2086
            response="$(curl -H "Authorization: Bearer ${MASTODON_ACCESS_TOKEN}" -s "${MASTODON_SERVER}/api/v1/statuses" -X POST $media_id -F "status=${mast_str}" -F "language=eng" -F "visibility=${mastpost_visibility}")"
            # check if there was an error
            if [[ "$(jq '.error' <<< "$response"|xargs)" == "null" ]]
            then
                echo "[$(date)][$APPNAME] Mastodon post generated successfully. Mastodon post available at: $(jq '.url' <<< "$response"|xargs)"
            else
                echo "[$(date)][$APPNAME] Mastodon post error. Mastodon returned this error: $(jq '.error' <<< "$response"|xargs)"
            fi

            # Update the Assoc Array with the latest values:
            # update mast_status values:
            VESSELS[$vessel:mast_lat]="${VESSELS[$vessel:lat]}"
            VESSELS[$vessel:mast_lon]="${VESSELS[$vessel:lon]}"
            VESSELS[$vessel:mast_last]="$(date +%s)"

            [[ -n "$DEBUG" ]] && echo "updated VESSELDICT[$mmsi]"
            # Increment notification count
            (( notification_count++ )) || true

        fi
    done

    [[ -n "$DEBUG" ]] && echo "Notification count: $notification_count"

    # Write VESSELDICT back to the file if it was changed:
    if (( notification_count > 0 ))
    then
        # Write back to file
        {
          declare -p KEY_INDEX
          declare -p VESSEL_INDEX
          declare -p VESSELS
          declare -p SHIPTYPE
        } > "$VESSELDBFILE" 2>/dev/null
        unset notification_count
    fi

    # Remove file block:
    rm -f "$VESSELDBLOCK"

    # Sleep a bit
    sleep $CHECK_INTERVAL

done
