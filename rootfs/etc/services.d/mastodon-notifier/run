#!/usr/bin/with-contenv bash
#shellcheck shell=bash
#shellcheck disable=SC2015,SC1090,SC2164,SC2001
###shellcheck disable=SC2016,SC2068,SC2076,SC2086,SC2015,SC2164,SC1090,SC2001

# Mastodon-Notifier
# Send notification to Mastoron
# create and maintain a CSV database with this data

# redirect stderr to stdout so it's picked up in the docker logs
exec 2>&1
# all errors will show a line number and the command used to produce the error
SCRIPT_PATH="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; pwd)/$(basename "$0")"
trap 'echo -e "[$(date)][$APPNAME][ERROR] $SCRIPT_PATH in line $LINENO when executing: $BASH_COMMAND returned ${?}"' ERR

APPNAME="$(hostname)/mastodon-notifier"
echo "[$(date)][$APPNAME] Started as an s6 service"

# Wait a cycle -- this gives AIS-Collect the chance to do at least an initial run:


[[ -z "${CHECK_INTERVAL}" ]] && CHECK_INTERVAL=30 || true
[[ -z "${VESSELDBFILE}" ]] && VESSELDBFILE="/data/vessel.db" || true
[[ -z "${VESSELDBLOCK}" ]] && VESSELDBLOCK="/run/vesseldb.lock" || true
[[ -z "${MASTODON_FORMAT}" ]] && MASTODON_FORMAT=("mast" "last_notif" "lat" "lon")
MASTODON_SERVER="${MASTODON_SERVER,,}"
[[ -z "${MASTODON_SERVER}" ]] && MASTODON_SERVER="airwaves.social"
[[ "${MASTODON_SERVER:0:7}" == "http://" ]] && MASTODON_SERVER="${MASTODON_SERVER:7}" || true
[[ "${MASTODON_SERVER:0:8}" == "https://" ]] && MASTODON_SERVER="${MASTODON_SERVER:8}" || true
MASTODON_SERVER="https://${MASTODON_SERVER}"
notification_count=0
[[ -z "$MASTODON_POST_VISIBILITY" ]] && MASTODON_POST_VISIBILITY=public
[[ -n "$DEBUG" ]] && MASTODON_POST_VISIBILITY="private"
IMAGECACHE="${VESSELDBFILE%/*}/imagecache"

touch "$VESSELDBFILE"
rm -f "$VESSELDBLOCK"

mkdir -p "${VESSELDBFILE%/*}/imagecache"

# Wait a cycle -- this gives AIS-Collect the chance to do at least an initial run:
sleep $CHECK_INTERVAL

# This is the format of the VESSELDICT associative array records:
# [mmsi, shipname, callsign, country, lat, lon, level, count, ppm, speed, destination, last_signal, notification_attributes_1, notification_attributes_2, ...]
#   0       1          2         3     4    5     6       7    8      9       10            11              12                          13       <-- field index for BASH
#   1       2          3         4     5    6     7       8    9     10       11            12              13                          14       <-- field index for AWK

# Define some functions to calculate distance between coordinates using Haversine:
deg2rad () {
    bc -l <<< "$1 * 0.0174532925"
}

rad2deg () {
    bc -l <<< "$1 * 57.2957795"
}

acos () {
    pi="3.141592653589793"
    bc -l <<< "$pi / 2 - a($1 / sqrt(1 - $1 * $1))"
}

distance () {
    lat_1="$1"
    lon_1="$2"
    lat_2="$3"
    lon_2="$4"
    delta_lat="$(bc <<<"$lat_2 - $lat_1")"
    delta_lon="$(bc <<<"$lon_2 - $lon_1")"
    lat_1="$(deg2rad "$lat_1")"
    lon_1="$(deg2rad "$lon_1")"
    lat_2="$(deg2rad "$lat_2")"
    lon_2="$(deg2rad "$lon_2")"
    delta_lat="$(deg2rad "$delta_lat")"
    delta_lon="$(deg2rad "$delta_lon")"
    distance="$(bc -l <<< "s($lat_1) * s($lat_2) + c($lat_1) * c($lat_2) * c($delta_lon)")"
    distance="$(acos "$distance")"
    distance="$(rad2deg "$distance")"
    distance="$(bc -l <<< "$distance * 60")"
    distance="$(bc <<<"scale=4; $distance / 1")"
    echo "$distance"
}

# ---------------------------------------------------------------------------------------

while true
do

    # 3 main arrays:
    # - VESSELDICT is an associative array that contains all the vessels, indexed by their MMSI.
    #   So: ${!VESSELDICT[@]} contains the list of MMSIs, and ${VESSELDICT[$mmsi]}
    #   contains a comma-separated list of parameter values.
    #
    # - vesselinfo is an associative array that contains the information of a single vessel from
    #   the VESSELDICT array. The ${headers[@]} array contains the keys for each of these values.
    #
    # - mast_status is extracted from the right-most "notif_x" field from vesselinfo that starts with "mast="
    #   This array contains information about previous notifications to Mastodon for this MMSI
    #   The keys to this array are defined in MASTODON_FORMAT

    # If there's a lock file, wait until it's gone\
    while [[ -f  $VESSELDBLOCK ]]
    do
        sleep 1
    done

    # Now lock the process for myself:
    touch "$VESSELDBLOCK"

    # First read the existing entries in from file
    if (( $(wc -l < "$VESSELDBFILE") > 0 ))
    then
        [[ -n "$DEBUG" ]] && echo reading shipdict from file || true
        source "$VESSELDBFILE"
    fi

    # Iterate through the ships:
    for vessel in "${VESSEL_INDEX[@]}"
    do

        [[ -z "${VESSELS[$vessel:mmsi]}" ]] && continue || true    # capture empty mmsi and skip
        # now we have the mastodon notification status of the vessel in mast_status. Let's check if we need to notify:
        unset notify

        # based on timing:
        if [[ -n "$MASTODON_NOTIFY_EVERY" ]] \
            && [[ -n "${VESSELS[$vessel:mast:last]}" ]] \
            && (( $(date +%s) <= ${VESSELS[$vessel:mast:last]} + MASTODON_NOTIFY_EVERY ))
        then
            [[ -n "$DEBUG" ]] && echo "${VESSELS[$vessel:mmsi]} (${VESSELS[$vessel:shipname]}) skipped notify based on timing. (Last notification was $(( $(date +%s) - ${VESSELS[$vessel:mast:last]} )) secs ago, minimum interval is $MASTODON_NOTIFY_EVERY secs )"
            notify="false"
        else
            [[ -n "$DEBUG" ]] && echo "${VESSELS[$vessel:mmsi]} (${VESSELS[$vessel:shipname]}) notification based on timing disabled or still too soon for re-notification"
        fi

        # based on distance from last notification:
        #shellcheck disable=SC2086
        if [[ -n "${MASTODON_MIN_DIST}" ]] \
            && [[ "$notify" != "false" ]] \
            && [[ -n "${VESSELS[$vessel:lat]}" ]] && [[ -n "${VESSELS[$vessel:lon]}" ]] \
            && [[ "${VESSELS[$vessel:lat]}" != "null" ]] && [[ "${VESSELS[$vessel:lon]}" != "null" ]] \
            && [[ -n "${VESSELS[$vessel:mast:lat]}" ]] && [[ -n "${VESSELS[$vessel:mast:lon]}" ]] \
            && [[ "$(bc -l <<<"scale=2; $(distance ${VESSELS[$vessel:mast:lat]} ${VESSELS[$vessel:mast:lon]} ${VESSELS[$vessel:lat]} ${VESSELS[$vessel:lon]}) < $MASTODON_MIN_DIST")" == "1" ]]
        then
            notify="false"
            [[ -n "$DEBUG" ]] && echo "${VESSELS[$vessel:mmsi]} (${VESSELS[$vessel:shipname]}) traveled distance too short - do not notify ( measured $(distance "${VESSELS[$vessel:mast:lat]}" "${VESSELS[$vessel:mast:lon]}" "${VESSELS[$vessel:lat]}" "${VESSELS[$vessel:lon]}") <= allowed $MASTODON_MIN_DIST )"
        else
            [[ -n "$DEBUG" ]] && echo "${VESSELS[$vessel:mmsi]} (${VESSELS[$vessel:shipname]}) notify not affected by distance"
        fi

        # don't notify if it matches the Skip Filter
        if [[ -n "${MASTODON_SKIP_FILTER}" ]] \
            && [[ "$notify" != "false" ]] \
            && [[ ${VESSELS[$vessel:mmsi]} =~ ${MASTODON_SKIP_FILTER} ]]
        then
            notify="false"
            [[ -n "$DEBUG" ]] && echo "${VESSELS[$vessel:mmsi]} (${VESSELS[$vessel:shipname]}) skipped because of mmsi filter match (${MASTODON_SKIP_FILTER})"
        else
            [[ -n "$DEBUG" ]] && echo "${VESSELS[$vessel:mmsi]} (${VESSELS[$vessel:shipname]}) mmsi skip filter not match or disabled or notify already set to false"
        fi

        if [[ -z "$notify" ]]
        then
            # we need to notify
            # First create notification string
            # These are the valid fields:
            # mmsi lat lon distance mmsi_type level count ppm heading cog speed to_bow to_stern to_starboard to_port shiptype msg_type country status callsign shipname destination last_signal mast:lat mast:lon mast:last
            links=""
            [[ -n "$MASTODON_LINK_SHIPXPLORER" ]] && links+="https://www.shipxplorer.com/data/vessels/IMO-MMSI-${VESSELS[$vessel:mmsi]} " || true
            [[ -n "$MASTODON_LINK_MARINETRAFFIC" ]] && links+="https://www.marinetraffic.com/en/ais/details/ships/${VESSELS[$vessel:mmsi]} " || true
            [[ -n "$MASTODON_LINK_VESSELFINDER" ]] && links+="https://www.vesselfinder.com/vessels/details/${VESSELS[$vessel:mmsi]} " || true

            mast_str="#VesselAlert #Ship #Vessel #AIS\n"
            [[ -n "${VESSELS[$vessel:shipname]}" ]] && mast_str+="Name: #$(sed -e ':a;s/^\(\([^"]*[,.]\?\|"[^",.]*"[,.]\?\)*"[^",.]*\)[,.]/\1 /;ta' -e 's|["'\'']||g' -e 's|[^A-Z0-9,\.\-]\+|_|g' -e 's|_,|,|g' <<< "${VESSELS[$vessel:shipname]}") "
            [[ -n "${VESSELS[$vessel:mmsi]}" ]] && mast_str+="#MMSI: #${VESSELS[$vessel:mmsi]} "
            [[ -n "${VESSELS[$vessel:callsign]}" ]] && mast_str+="Call: #${VESSELS[$vessel:callsign]} "
            [[ -n "${VESSELS[$vessel:shiptype]}" ]] && mast_str+="Type: ${SHIPTYPE[${VESSELS[$vessel:shiptype]}]}"
            mast_str+="\n"

            [[ -n "${VESSELS[$vessel:country]}" ]] && mast_str+="#Flag: #${VESSELS[$vessel:country]} "
            mast_str+="Last seen: $(date -d @$(( $(date +%s) - ${VESSELS[$vessel:last_signal]} )) +"%d-%b-%Y %H:%M:%S %Z") Msgs recvd: ${VESSELS[$vessel:count]}"
            mast_str+="\n"

            [[ -n "${VESSELS[$vessel:speed]}" ]] && mast_str+="Speed: ${VESSELS[$vessel:speed]} kts "
            [[ -n "${VESSELS[$vessel:heading]}" ]] && mast_str+="Heading: ${VESSELS[$vessel:speed]} deg "
            [[ -n "${VESSELS[$vessel:destination]}" ]] && mastr_str+="Destination: $(sed -e ':a;s/^\(\([^"]*[,.]\?\|"[^",.]*"[,.]\?\)*"[^",.]*\)[,.]/\1 /;ta' -e 's|["'\'']||g' -e 's|[^A-Z0-9,\.\-]\+|_|g' -e 's|_,|,|g' <<< "${VESSELS[$vessel:destination]}")"
            mast_str+="\n"

            mast_str+="#Signal (#RSSI): $(printf "%.1f dBFS" "${VESSELS[$vessel:level]}")"
            [[ -n "$links" ]] && mast_str+="\n$links"

            mast_str="$(sed -e 's|\\n|\n|g' <<< "$mast_str")"

            # Now we can finally send this to Mastodon
            # First let's get an image if it exists from MarineVessel:

            image_link="https://photos.marinetraffic.com/ais/showphoto.aspx?mmsi=${VESSELS[$vessel:mmsi]}"
            media_id=""

            # Try to get an image if there isn't already one:
            if [[ ! -f "$IMAGECACHE/${VESSELS[$vessel:mmsi]}.jpg" ]]
            then
                if ! curl -sL -A "Mozilla/5.0 (X11; Linux x86_64; rv:97.0) Gecko/20100101 Firefox/97.0" "$image_link" -o  "$IMAGECACHE/${VESSELS[$vessel:mmsi]}.jpg"
                then
                    rm -f "$IMAGECACHE/${VESSELS[$vessel:mmsi]}.jpg"
                fi
            fi
            # If the file starts with <!DOCTYPE html>, we know it was an error message and we can erase it:
            if grep '<!DOCTYPE html>' < <(dd bs=1 count=15 if="$IMAGECACHE/${VESSELS[$vessel:mmsi]}.jpg" 2>/dev/null) >/dev/null 2>&1
            then
                rm -f "$IMAGECACHE/${VESSELS[$vessel:mmsi]}.jpg"
            fi

            # If the image still exists, then upload it to Mastodon:
            if [[ -f "$IMAGECACHE/${VESSELS[$vessel:mmsi]}.jpg" ]]
            then
                response="$(curl -s -H "Authorization: Bearer ${MASTODON_ACCESS_TOKEN}" -H "Content-Type: multipart/form-data" -X POST "${MASTODON_SERVER}/api/v1/media" --form file="@$IMAGECACHE/${VESSELS[$vessel:mmsi]}.jpg")"
                [[ "$(jq '.id' <<< "$response" | xargs)" != "null" ]] && mast_id="$(jq '.id' <<< "$response" | xargs)" || mast_id=""
                [[ -n "${mast_id}" ]] && media_id="-F media_ids[]=${mast_id}"
                echo "[$(date)][$APPNAME] image for ${VESSELS[$vessel:mmsi]} (${VESSELS[$vessel:shipname]}) uploaded to Mastodon"
            fi

            # Now send a Toot:
            #shellcheck disable=SC2086
            response="$(curl -H "Authorization: Bearer ${MASTODON_ACCESS_TOKEN}" -s "${MASTODON_SERVER}/api/v1/statuses" -X POST $media_id -F "status=${mast_str}" -F "language=eng" -F "visibility=${MASTODON_POST_VISIBILITY}")"
            # check if there was an error
            if [[ "$(jq '.error' <<< "$response"|xargs)" == "null" ]]
            then
                echo "[$(date)][$APPNAME] Mastodon post for ${VESSELS[$vessel:mmsi]} (${VESSELS[$vessel:shipname]}) generated successfully. Mastodon post available at: $(jq '.url' <<< "$response"|xargs)"
            else
                echo "[$(date)][$APPNAME] Mastodon post error for ${VESSELS[$vessel:mmsi]} (${VESSELS[$vessel:shipname]}). Mastodon returned this error: $(jq '.error' <<< "$response"|xargs)"
            fi

            # Update the Assoc Array with the latest values:
            # update mast_status values:
            VESSELS[$vessel:mast:lat]="${VESSELS[$vessel:lat]}"
            VESSELS[$vessel:mast:lon]="${VESSELS[$vessel:lon]}"
            VESSELS[$vessel:mast:last]="$(date +%s)"

            [[ -n "$DEBUG" ]] && echo "updated VESSELS[$mmsi]"
            # Increment notification count
            (( notification_count++ )) || true
        fi
    done

    [[ -n "$DEBUG" ]] && echo "Notification count: $notification_count"

    # Write arrays back to the file if it was changed:
    if (( notification_count > 0 ))
    then
        # Write back to file
        {
          declare -p KEY_INDEX
          declare -p VESSEL_INDEX
          declare -p VESSELS
          declare -p SHIPTYPE
        } > "$VESSELDBFILE" 2>/dev/null
        unset notification_count
    fi

    # Remove file block:
    rm -f "$VESSELDBLOCK"

    # Sleep a bit
    sleep $CHECK_INTERVAL

done
