#!/usr/bin/with-contenv bash
#shellcheck shell=bash
#shellcheck disable=SC2016,SC2068,SC2076,SC2086,SC2015,SC2164,SC1090

# AIS-Collect:
# read AIS data from a AIS-Catcher web service and
# create and maintain a CSV database with this data
#---------------------------------------------------------------------------------------------
# Copyright (C) 2022-2023, Ramon F. Kolb (kx1t)
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program.
# If not, see <https://www.gnu.org/licenses/>.
#---------------------------------------------------------------------------------------------

# redirect stderr to stdout so it's picked up in the docker logs
##exec 2>&1
# all errors will show a line number and the command used to produce the error
SCRIPT_PATH="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; pwd)/$(basename "$0")"
trap 'echo -e "[$(date)][$APPNAME][ERROR] $SCRIPT_PATH in line $LINENO when executing: $BASH_COMMAND returned ${?}"' ERR

APPNAME="$(hostname)/ais-collect"
echo "[$(date)][$APPNAME] Started as an s6 service"
[[ -n "$DEBUG" ]] && echo "[$(date)][$APPNAME] DEBUG=ON" || echo "[$(date)][$APPNAME] DEBUG=OFF"

declare -A VESSELS
declare -a VESSEL_INDEX
declare -a KEY_INDEX

declare -A SHIPTYPE=([0]="" [1]="" [2]="" [3]="" [4]="" [5]="" [6]="" [7]="" [8]="" [9]="" [10]="" [11]="" [12]="" [13]="" [14]="" [15]="" [16]="" [17]="" [18]="" [19]="" [20]="#WIG (Wing in ground)" [21]="#WIG #Hazard cat A" [22]="#WIG #Hazard cat B" [23]="#WIG #Hazard cat B" [24]="#WIG #Hazard cat D" [25]="#WIG" [26]="#WIG" [27]="#WIG" [28]="#WIG" [29]="#WIG" [30]="#Fishing" [31]="#Towing" [32]="#Towing (Large)" [33]="#Dredging" [34]="#Diving" [35]="#Military #Mil" [36]="#Sailing" [37]="#Pleasure Craft" [38]="" [39]="" [40]="#HiSpeed" [41]="#HiSpeed" [42]="#HiSpeed" [43]="#HiSpeed" [44]="#HiSpeed" [45]="#HiSpeed" [46]="#HiSpeed" [47]="#HiSpeed" [48]="#HiSpeed" [49]="#HiSpeed" [50]="#Pilot vessel" [51]="#SAR" [52]="#Tug" [53]="#Port_Tender" [54]="#Anti_Pollution" [55]="#Law #Enforcement" [56]="#Local vessel" [57]="#Local vessel" [58]="#Medical pransport" [59]="#Special vessel" [60]="#Passenger vessel" [61]="#Passenger vessel" [62]="#Passenger vessel" [63]="#Passenger vessel" [64]="#Passenger vessel" [65]="#Passenger vessel" [66]="#Passenger vessel" [67]="#Passenger vessel" [68]="#Passenger vessel" [69]="#Passenger vessel" [70]="#Cargo" [71]="#Cargo #Hazard cat A" [72]="#Cargo #Hazard cat B" [73]="#Cargo #Hazard cat C" [74]="#Cargo #Hazard cat D" [75]="#Cargo" [76]="#Cargo" [77]="#Cargo" [78]="#Cargo" [79]="#Cargo" [80]="#Tanker" [81]="#Tanker #Hazard cat A" [82]="#Tanker #Hazard cat B" [83]="#Tanker #Hazard cat C" [84]="#Tanker" [85]="#Tanker" [86]="#Tanker" [87]="#Tanker" [88]="#Tanker" [89]="#Tanker" [90]="#Tanker" [91]="" [92]="" [93]="" [94]="" [95]="" [96]="" [97]="" [98]="" [99]="" )

#Add notif_key style additional keys here, as needed for each notification service:
KEY_INDEX+=("mast_lat" "mast_lon" "mast_last")

[[ -z "${CHECK_INTERVAL}" ]] && CHECK_INTERVAL=30 || true
[[ -z "${VESSELDBFILE}" ]] && VESSELDBFILE="/data/vessel.db" || true
[[ -z "${VESSELDBLOCK}" ]] && VESSELDBLOCK="/run/vesseldb.lock" || true
[[ -z "${MIN_MSG_COUNT}" ]] && MIN_MSG_COUNT=5 || true
	[[ -z "${MAX_MSG_AGE}" ]] && MAX_MSG_AGE=604800    # 1 week before a record gets erased from the database
[[ "${AIS_URL:0:4}" != "http" ]] && AIS_URL="http://${AIS_URL}"
[[ "${AIS_URL: -4}" != "json" ]] && AIS_URL="${AIS_URL}/ships.json"

touch "$VESSELDBFILE"
rm -f "$VESSELDBLOCK"

while true
do
    # If there's a lock file, wait until it's gone
    while [[ -f  $VESSELDBLOCK ]]
    do
        sleep 1
    done

    # Now lock the process for myself:
    touch "$VESSELDBLOCK"

    # First read the existing entries in from file
    if (( $(wc -l < "$VESSELDBFILE") > 0 ))
    then
        [[ -n "$DEBUG" ]] && echo reading VESSELS dict from file || true
        source "$VESSELDBFILE"
    fi

    # Now update it with the ones from the AIS_URL website.
    # The curl ... | jq ... command below creates a vertical list of key=value strings
    # from the JSON file in the AIS_URL. Each new ship starts with its mmsi as first key so we can use that as index.
    # The result is 3 arrays:
    # - VESSEL_INDEX contains a list of all MMSIs
    # - KEY_INDEX contains a list of all keys
    # - VESSELS[$mmsi:$key] contains values for mmsi=$mmsi and key=$key

    # Read VESSELS from the AIS_URL:
    ships_json="$(curl -sSL $AIS_URL)"
    eval "$(jq -r '.ships[] | .mmsi as $mmsi | to_entries[] | @sh "VESSELS[\("\($mmsi):\(.key)")]=\(.value)"' <<< "$ships_json" )"
    # Add a last_updated field to all the newly entered or updated vessels:
    eval "$(jq -r '.ships[] | .mmsi as $mmsi | to_entries[] | "VESSELS[\("\($mmsi):")"' <<< "$ships_json"|sort -u | sed 's/:/:last_updated\]='"$(date +%s)"'/g')"

    # create the indices and clean up text
    for keyvalue in ${!VESSELS[@]}
    do
        # add key to KEY_INDEX:
        [[ -n "${keyvalue#*:}" ]] && [[ ! " ${KEY_INDEX[*]} " =~ " ${keyvalue#*:} " ]] && KEY_INDEX+=("${keyvalue#*:}") || true
        # add mmsi to VESSEL_INDEX:
        [[ -n "${keyvalue%%:*}" ]] && [[ ! " ${VESSEL_INDEX[*]} " =~ " ${keyvalue%%:*} " ]] && VESSEL_INDEX+=("${keyvalue%%:*}") || true
        # if the key is "shipname" or "destination", then clean up the text to ensure hashtagging works
        [[ "${keyvalue##*:}" ==  "shipname" ]] && VESSELS[$keyvalue]="$(sed -e ':a;s/^\(\([^"]*[,.]\?\|"[^",.]*"[,.]\?\)*"[^",.]*\)[,.]/\1 /;ta' -e 's|["'\'']||g' -e 's|[^A-Z0-9,\.\-]\+|_|g' -e 's|_,|,|g' -e 's|\.||g' <<< "${VESSELS[$keyvalue]}")"
        [[ "${keyvalue##*:}" ==  "destination" ]] && VESSELS[$keyvalue]="$(sed -e ':a;s/^\(\([^"]*[,.]\?\|"[^",.]*"[,.]\?\)*"[^",.]*\)[,.]/\1 /;ta' -e 's|["'\'']||g' -e 's|[^A-Z0-9,\.\-]\+|_|g' -e 's|_,|,|g' -e 's|\.||g' <<< "${VESSELS[$keyvalue]}")"
    done

    # Clean out the ones that are too old or that don't have enough messages:
    for vessel in "${VESSEL_INDEX[@]}"
    do

        [[ -n "${VESSELS[${vessel}:last_updated]}" ]] && age=$(( $(date +%s) - ${VESSELS[${vessel}:last_updated]} )) || age=0
        [[ -n "${VESSELS[${vessel}:count]}" ]] && count="${VESSELS[${vessel}:count]}" || count=$MIN_MSG_COUNT
        (( count < MIN_MSG_COUNT )) && [[ -n "${VESSELS[${vessel}:min_count_exceeded]}" ]] && count=$MIN_MSG_COUNT
        (( count >= MIN_MSG_COUNT )) && VESSELS[${vessel}:min_count_exceeded]="true"

        if     [[ ! $age =~ ^[0-9]+$ ]] \
            || (( age > MAX_MSG_AGE )) \
            || (( count < MIN_MSG_COUNT ))
        then
            [[ -n "$DEBUG" ]] && echo "removed ${vessel}: pattern ($age)=$([[ ! $age =~ ^[0-9]+$ ]] && echo -n true || echo -n false) >maxage ($age>$MAX_MSG_AGE)=$( (( age > MAX_MSG_AGE )) && echo -n true || echo -n false) MINMSGCNT ($count<$MIN_MSG_COUNT)=$( (( count < MIN_MSG_COUNT )) && echo true || echo false)"
            for key in "${KEY_INDEX[@]}"
            do
                unset "VESSELS[${vessel}:${key}]"
            done
        fi

        # Make sure that no notifications will be sent if MASTODON_ONLY_NEW_ON_STARTUP is set and this is the first run ever:
        # Note -- this code has cross-contamination from the Mastodon-Notifier and will need to be updated if new
        # notification media are added. This is unfortunate but to avoid it means adding a LOT more logic.
        # If the criteria are met, we will tag the last notification time to the current time, so it won't renotify until much later.
        if     [[ -n "$MASTODON_ONLY_NEW_ON_STARTUP" ]] \
            && [[ ! -f /data/container_has_run_before ]]
        then
            spread="$(bc -l <<< "$MASTODON_NOTIFY_EVERY * 0.2")"
	    printf -v adjust "%.0f" "$(bc -l <<< "($RANDOM/32767)*$spread - $spread/2")"
            VESSELS[${vessel}:mast:last]="$(( $(date +%s) + adjust ))"
        fi

        # while we are at it, clean up the vessel neam and destination:
        [[ -n "${VESSELS[${vessel}:shipname]}" ]] && VESSELS[${vessel}:shipname]="$(sed -e ':a;s/^\(\([^"]*[,.]\?\|"[^",.]*"[,.]\?\)*"[^",.]*\)[,.]/\1 /;ta' -e 's|["'\'']||g' -e 's|[^A-Z0-9,\.\-]\+|_|g' -e 's|_,|,|g' <<< "${VESSELS[$vessel:shipname]}")"
        [[ -n "${VESSELS[${vessel}:destination]}" ]] && VESSELS[${vessel}:destination]="$(sed -e ':a;s/^\(\([^"]*[,.]\?\|"[^",.]*"[,.]\?\)*"[^",.]*\)[,.]/\1 /;ta' -e 's|["'\'']||g' -e 's|[^A-Z0-9,\.\-]\+|_|g' -e 's|_,|,|g' <<< "${VESSELS[$vessel:destination]}")"
    done

    if     [[ -n "$MASTODON_ONLY_NEW_ON_STARTUP" ]] \
        && [[ ! -f /data/container_has_run_before ]]
    then
        touch /data/container_has_run_before
        [[ -n "$DEBUG" ]] && echo "This was the first container run ever and MASTODON_ONLY_NEW_ON_STARTUP was set. All vessels known as of this initial run have been tagged notified with date ${VESSELS[${vessel}:mast:last]}"
    fi

    # Write back to file
    # Write back to file
    {
        declare -p KEY_INDEX
        declare -p VESSEL_INDEX
        declare -p VESSELS
        declare -p SHIPTYPE ;} > "$VESSELDBFILE"

    [[ -n "$DEBUG" ]] && echo "wrote back to file"
    rm -f "$VESSELDBLOCK"

    sleep $CHECK_INTERVAL

done
