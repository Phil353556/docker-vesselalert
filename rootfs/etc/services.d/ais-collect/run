#!/usr/bin/with-contenv bash
#shellcheck shell=bash
#shellcheck disable=SC2016,SC2068,SC2076,SC2086,SC2015,SC2164,SC1090
# set -x
# AIS-Collect:
# read AIS data from a AIS-Catcher web service and
# create and maintain a CSV database with this data

# If no NOTIFY_INTERVAL is defined then set it to 24 hours

# redirect stderr to stdout so it's picked up in the docker logs
##exec 2>&1
# all errors will show a line number and the command used to produce the error
SCRIPT_PATH="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; pwd)/$(basename "$0")"
trap 'echo -e "[$(date)][$APPNAME][ERROR] $SCRIPT_PATH in line $LINENO when executing: $BASH_COMMAND returned ${?}"' ERR

APPNAME="$(hostname)/ais-collect"
echo "[$(date)][$APPNAME] Started as an s6 service"
echo "[$(date)][$APPNAME] DEBUG=$DEBUG"

declare -A VESSELS
declare -a VESSEL_INDEX
declare -a KEY_INDEX

declare -A SHIPTYPE=([0]="Not Available" [1]="#Reserved" [2]="#Reserved" [3]="#Reserved" [4]="#Reserved" [5]="#Reserved" [6]="#Reserved" [7]="#Reserved" [8]="#Reserved" [9]="#Reserved" [10]="#Reserved" [11]="#Reserved" [12]="#Reserved" [13]="#Reserved" [14]="#Reserved" [15]="#Reserved" [16]="#Reserved" [17]="#Reserved" [18]="#Reserved" [19]="#Reserved" [20]="#WIG (Wing in ground)" [21]="#WIG #Hazard cat A" [22]="#WIG #Hazard cat B" [23]="#WIG #Hazard cat B" [24]="#WIG #Hazard cat D" [25]="#WIG #Reserved" [26]="#WIG #Reserved" [27]="#WIG #Reserved" [28]="#WIG #Reserved" [29]="#WIG #Reserved" [30]="#Fishing" [31]="#Towing" [32]="#Towing (Large)" [33]="#Dredging" [34]="#Diving" [35]="#Military #Mil" [36]="#Sailing" [37]="#Pleasure Craft" [38]="#Reserved" [39]="#Reserved" [40]="#HiSpeed" [41]="#HiSpeed" [42]="#HiSpeed" [43]="#HiSpeed" [44]="#HiSpeed" [45]="#HiSpeed" [46]="#HiSpeed" [47]="#HiSpeed" [48]="#HiSpeed" [49]="#HiSpeed" [50]="#Pilot vessel" [51]="#SAR" [52]="#Tug" [53]="#Port_Tender" [54]="#Anti_Pollution" [55]="#Law #Enforcement" [56]="#Local vessel" [57]="#Local vessel" [58]="#Medical pransport" [59]="#Special vessel" [60]="#Passenger vessel" [61]="#Passenger vessel" [62]="#Passenger vessel" [63]="#Passenger vessel" [64]="#Passenger vessel" [65]="#Passenger vessel" [66]="#Passenger vessel" [67]="#Passenger vessel" [68]="#Passenger vessel" [69]="#Passenger vessel" [70]="#Cargo" [71]="#Cargo #Hazard cat A" [72]="#Cargo #Hazard cat B" [73]="#Cargo #Hazard cat C" [74]="#Cargo #Hazard cat D" [75]="#Cargo" [76]="#Cargo" [77]="#Cargo" [78]="#Cargo" [79]="#Cargo" [80]="#Tanker" [81]="#Tanker #Hazard cat A" [82]="#Tanker #Hazard cat B" [83]="#Tanker #Hazard cat C" [84]="#Tanker" [85]="#Tanker" [86]="#Tanker" [87]="#Tanker" [88]="#Tanker" [89]="#Tanker" [90]="#Tanker" [91]="#Other" [92]="#Other" [93]="#Other" [94]="#Other" [95]="#Other" [96]="#Other" [97]="#Other" [98]="#Other" [99]="#Other" )

#Add notif_key style additional keys here, as needed for each notification service:
KEY_INDEX+=("mast_lat" "mast_lon" "mast_last")

[[ -z "${CHECK_INTERVAL}" ]] && CHECK_INTERVAL=30 || true
[[ -z "${VESSELDBFILE}" ]] && VESSELDBFILE="/data/vessel.db" || true
[[ -z "${VESSELDBLOCK}" ]] && VESSELDBLOCK="/run/vesseldb.lock" || true
[[ -z "${MIN_MSG_COUNT}" ]] && MIN_MSG_COUNT=5 || true
[[ -z "${MAX_MSG_AGE}" ]] && MAX_MSG_AGE=86400
[[ "${AIS_URL:0:4}" != "http" ]] && AIS_URL="http://${AIS_URL}"
[[ "${AIS_URL: -4}" != "json" ]] && AIS_URL="${AIS_URL}/ships.json"

touch "$VESSELDBFILE"
rm -f "$VESSELDBLOCK"

while true
do
    # If there's a lock file, wait until it's gone
    while [[ -f  $VESSELDBLOCK ]]
    do
        sleep 1
    done

    # Now lock the process for myself:
    touch "$VESSELDBLOCK"

    # First read the existing entries in from file
    if (( $(wc -l < "$VESSELDBFILE") > 0 ))
    then
        [[ -n "$DEBUG" ]] && echo reading VESSELS dict from file || true
        source "$VESSELDBFILE"
    fi

    # Now update it with the ones from the AIS_URL website.
    # The curl ... | jq ... command below creates a vertical list of key=value strings
    # from the JSON file in the AIS_URL. Each new ship starts with its mmsi as first key so we can use that as index.
    # The result is 3 arrays:
    # - VESSEL_INDEX contains a list of all MMSIs
    # - KEY_INDEX contains a list of all keys
    # - VESSELS[$mmsi:$key] contains values for mmsi=$mmsi and key=$key

    # Read VESSELS from the AIS_URL:
    ships_json="$(curl -sSL $AIS_URL)"
    eval "$(jq -r '.ships[] | .mmsi as $mmsi | to_entries[] | @sh "VESSELS[\("\($mmsi):\(.key)")]=\(.value)"' <<< "$ships_json" )"
    # Add a last_updated field to all the newly entered or updated vessels:
    eval "$(jq -r '.ships[] | .mmsi as $mmsi | to_entries[] | "VESSELS[\("\($mmsi):")"' <<< "$ships_json"|sort -u | sed 's/:/:last_updated\]='"$(date +%s)"'/g')"

    # create the indices and clean up text
    for keyvalue in ${!VESSELS[@]}
    do
        # add key to KEY_INDEX:
        [[ -n "${keyvalue##*:}" ]] && [[ ! " ${KEY_INDEX[*]} " =~ " ${keyvalue##*:} " ]] && KEY_INDEX+=("${keyvalue##*:}") || true
        # add mmsi to VESSEL_INDEX:
        [[ -n "${keyvalue%%:*}" ]] && [[ ! " ${VESSEL_INDEX[*]} " =~ " ${keyvalue%%:*} " ]] && VESSEL_INDEX+=("${keyvalue%%:*}") || true
        # if the key is "shipname" or "destination", then clean up the text to ensure hashtagging works
        [[ "${keyvalue##*:}" ==  "shipname" ]] && VESSELS[$keyvalue]="$(sed -e ':a;s/^\(\([^"]*[,.]\?\|"[^",.]*"[,.]\?\)*"[^",.]*\)[,.]/\1 /;ta' -e 's|["'\'']||g' -e 's|[^A-Z0-9,\.\-]\+|_|g' -e 's|_,|,|g' <<< "${VESSELS[$keyvalue]}")"
        [[ "${keyvalue##*:}" ==  "destination" ]] && VESSELS[$keyvalue]="$(sed -e ':a;s/^\(\([^"]*[,.]\?\|"[^",.]*"[,.]\?\)*"[^",.]*\)[,.]/\1 /;ta' -e 's|["'\'']||g' -e 's|[^A-Z0-9,\.\-]\+|_|g' -e 's|_,|,|g' <<< "${VESSELS[$keyvalue]}")"
    done

    # Clean out the ones that are too old or that don't have enough messages:
    for vessel in "${VESSEL_INDEX[@]}"
    do

        [[ -n "${VESSELS[${vessel}:last_updated]}" ]] && age=$(( $(date +%s) - ${VESSELS[${vessel}:last_updated]} )) || age=0
        [[ -n "${VESSELS[${vessel}:count]}" ]] && count="${VESSELS[${vessel}:count]}" || count=$MIN_MSG_COUNT

        if [[ ! $age =~ ^[0-9]+$ ]] \
        || (( age > MAX_MSG_AGE )) \
        || (( count < MIN_MSG_COUNT ))
        then
            [[ -n "$DEBUG" ]] && echo "removed ${vessel}: pattern ($age)=$([[ ! $age =~ ^[0-9]+$ ]] && echo -n true || echo -n false) >maxage ($age>$MAX_MSG_AGE)=$( (( age > MAX_MSG_AGE )) && echo -n true || echo -n false) MINMSGCNT ($count<$MIN_MSG_COUNT)=$( (( count < MIN_MSG_COUNT )) && echo true || echo false)"
            for key in "${KEY_INDEX[@]}"
            do
                unset "VESSELS[${vessel}:${key}]"
            done
            [[ "${VERBOSELOGS,,}" == "on" ]] && echo "[$(date)][$APPNAME] $vessel - removed from DB $( (( ${VESSELS["${vessel}:last_signal"]} > MAX_MSG_AGE )) && echo -n "- too old (${VESSELS["${vessel}:last_signal"]} > $MAX_MSG_AGE)" || true )$( (( ${VESSELS["${vessel}:count"]} < MIN_MSG_COUNT )) && echo -n "- too few messages (<$MIN_MSG_COUNT)" || true )" || true
        else
            [[ -n "$DEBUG" ]] && echo "kept ${vessel}"
        fi

        # while we are at it, clean up the vessel neam and destination:
        [[ -n "${VESSELS[$vessel:shipname]}" ]] && VESSELS[${vessel}:shipname]="$(sed -e ':a;s/^\(\([^"]*[,.]\?\|"[^",.]*"[,.]\?\)*"[^",.]*\)[,.]/\1 /;ta' -e 's|["'\'']||g' -e 's|[^A-Z0-9,\.\-]\+|_|g' -e 's|_,|,|g' <<< "${VESSELS[$vessel:shipname]}")"
        [[ -n "${VESSELS[$vessel:destination]}" ]] && VESSELS[${vessel}:destination]="$(sed -e ':a;s/^\(\([^"]*[,.]\?\|"[^",.]*"[,.]\?\)*"[^",.]*\)[,.]/\1 /;ta' -e 's|["'\'']||g' -e 's|[^A-Z0-9,\.\-]\+|_|g' -e 's|_,|,|g' <<< "${VESSELS[$vessel:destination]}")"

    done

    # Write back to file
    # Write back to file
    {
        declare -p KEY_INDEX
        declare -p VESSEL_INDEX
        declare -p VESSELS
        declare -p SHIPTYPE
    } > "$VESSELDBFILE" 2>/dev/null

    [[ -n "$DEBUG" ]] && echo wrote back to file
    rm -f "$VESSELDBLOCK"

    sleep $CHECK_INTERVAL

done
